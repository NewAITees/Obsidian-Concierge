---
description: MVPの定義と設計ガイドライン
globs: 
alwaysApply: false
---
Definition of MVP

# MVPの定義と設計ガイドライン

## 1. MVPの基本概念

MVP（Minimum Viable Product：最小限の実用可能な製品）とは、最小限の機能と労力で、ユーザーの問題を解決し、フィードバックを得るための初期バージョンの製品です。

```mermaid
graph LR
    A[アイデア] --> B[MVP]
    B --> C[フィードバック]
    C --> D[改良]
    D --> B
```

### MVPの目的
- 最小限のリソースでユーザーの主要な問題を解決する
- 早期にユーザーからフィードバックを得る
- 製品の仮説を検証する
- 開発リスクを低減する
- 無駄な機能開発を避ける

## 2. MVPを定義するための基準

### 2.1 ユーザー価値基準
MVPは以下の質問に対する答えを明確に持つ必要があります：

- このMVPは誰のためのものか？（ターゲットユーザー）
- どのような問題を解決するのか？（解決する課題）
- なぜユーザーはこの解決策を必要としているのか？（価値提案）
- どのように問題を解決するのか？（解決方法）
- ユーザーがMVPを使用した後の成功とは何か？（成功指標）

### 2.2 技術的ミニマリズム（ローカルアプリ向け）
- シンプルで理解しやすい技術スタックを選択する
- 標準的なライブラリを優先し、依存関係を最小限に抑える
- インストールと設定を簡素化する
- 複雑なアーキテクチャより、動作の確実性を優先する
- クロスプラットフォーム対応よりも、特定環境での堅牢な動作を優先する

### 2.3 持続可能性とユーザー体験
- 導入障壁を最小限にする（簡単なインストール、最小限の設定）
- データの可搬性と安全性を確保する
- 簡潔で明確なドキュメントを提供する
- ユーザーが自力でトラブルシューティングできる仕組みを用意する

## 3. MVPスコープの決定方法

### 3.1 コア機能特定のためのフレームワーク

```mermaid
quadrantChart
    title 機能優先度マトリックス
    x-axis 実装の複雑さ (低) --> (高)
    y-axis ユーザー価値 (低) --> (高)
    quadrant-1 今すぐ実装
    quadrant-2 次のフェーズで検討
    quadrant-3 実装しない
    quadrant-4 実装の簡素化を検討
```

### 3.2 ユーザージャーニーマッピング
1. ユーザーの主要なゴールを特定
2. そのゴールに至るまでの最短パスを特定
3. 各ステップで必要最小限の機能を定義
4. 「あったら良い」機能と「必須」機能を区別

### 3.3 機能削減のための質問リスト
- この機能がなくても製品は使用できるか？
- この機能は初期ユーザーの80%以上に価値を提供するか？
- この機能は製品の中核的な価値提案に直接貢献するか？
- この機能の実装コストとリスクは正当化できるか？
- この機能は後から追加することが著しく困難になるか？

## 4. MVPの具体的な定義プロセス

```mermaid
graph TD
    A[ユーザーニーズの特定] --> B[ユースケースの定義]
    B --> C[必須機能の特定]
    C --> D[技術的実現可能性の評価]
    D --> E[MVP機能セットの確定]
    E --> F[成功指標の設定]
```

### 4.1 ユーザーストーリーを使ったMVP定義
主要なユーザーストーリーを特定し、それらを満たす最小限の機能セットをMVPとして定義します。

```
形式：「〜として、〜したい、なぜなら〜だからだ」

例：
- 新規ユーザーとして、簡単に登録したい、なぜなら時間をかけずにサービスを試したいからだ
- 顧客として、商品を検索したい、なぜなら欲しい商品を見つけたいからだ
- 購入者として、商品を購入したい、なぜなら見つけた商品を入手したいからだ
```

### 4.2 MVP機能の擬似コードによる表現

```
FUNCTION MVP_DEFINITION(ビジネス目標, ユーザーニーズ, リソース制約)
    // 入力: ビジネス目標、ユーザーニーズ、リソース制約
    // 出力: MVP機能セット、除外機能セット、成功指標
    
    必須ユースケース = 特定(ビジネス目標, ユーザーニーズ)
    
    候補機能リスト = []
    
    FOR EACH ユースケース IN 必須ユースケース
        機能 = 抽出必要機能(ユースケース)
        候補機能リスト.追加(機能)
    END FOR
    
    候補機能リスト = 優先度評価(候補機能リスト, ユーザーニーズ)
    候補機能リスト = 複雑性評価(候補機能リスト, リソース制約)
    
    MVP機能セット = []
    除外機能セット = []
    
    FOR EACH 機能 IN 候補機能リスト
        IF 必須か(機能) AND 実現可能か(機能, リソース制約) THEN
            MVP機能セット.追加(機能)
        ELSE
            除外機能セット.追加(機能)
        END IF
    END FOR
    
    成功指標 = 定義成功指標(MVP機能セット, ビジネス目標)
    
    RETURN MVP機能セット, 除外機能セット, 成功指標
END FUNCTION
```

## 5. MVPフェーズの分割方法

ユーザー体験の完全なフローを確保しながら、機能の範囲を段階的に拡張していくアプローチが効果的です。

### 5.1 MVPのフェーズ分け例

```mermaid
graph LR
    A[MVP 0.1: プロトタイプ] --> B[MVP 1.0: コア機能]
    B --> C[MVP 1.5: 基本拡張]
    C --> D[MVP 2.0: 完全版]
```

| フェーズ | 目的 | 含まれる機能 | 評価基準 |
|---------|------|-------------|----------|
| MVP 0.1 | 概念実証、初期フィードバック | 最低限の機能セット、UI/UXは簡素でも可 | 基本的なユーザーストーリーの実行が可能か |
| MVP 1.0 | 実用最小限の製品、初期ユーザー獲得 | 主要ユーザーストーリーをカバーする機能 | 実際のユーザーが基本タスクを完了できるか |
| MVP 1.5 | ユーザー体験の向上、ユーザー基盤の拡大 | 基本的な拡張機能、初期フィードバックに基づく改善 | ユーザー満足度、継続率の向上 |
| MVP 2.0 | 製品の完成、市場への本格展開 | 完全な機能セット、洗練されたUI/UX | 市場での競争力、長期的なユーザー獲得・維持 |

### 5.2 各フェーズでの評価方法
- ユーザーフィードバックの収集方法
- 定量的・定性的成功指標の測定
- 次フェーズへの移行条件

## 6. MVPの成功指標の設定

MVPの成功を測るための主要指標と目標値を設定します。

### 6.1 ユーザー体験指標（ローカルアプリ向け）
- ユーザーストーリーの達成度（各ストーリーが実際に実現できるか）
- 操作ステップ数（少ないほど良い）
- 学習曲線の緩やかさ（初めてのユーザーが直感的に操作できるか）
- エラー発生時の回復しやすさ

### 6.2 実用性指標
- 一般的なユースケースの完了時間
- データ入出力の正確性
- 設定やカスタマイズの容易さ
- 既存ワークフローとの統合しやすさ

### 6.3 技術指標（シンプル版）
- 起動時間と基本操作の応答性
- クラッシュ頻度（少ないほど良い）
- リソース使用量（CPU、メモリ、ディスク）
- インストール成功率と難易度

## 7. MVPからの学習とイテレーション

```mermaid
graph TD
    A[MVP実装] --> B[データ収集]
    B --> C[分析と学習]
    C --> D[仮説の修正]
    D --> E[次のイテレーション計画]
    E --> A
```

### 7.1 学習サイクルの最適化
- フィードバック収集の効率化
- データ分析の迅速化
- 意思決定プロセスの簡素化

### 7.2 ピボットと拡張の判断基準
- 現在の方向性を継続すべきか
- 修正（ピボット）が必要か
- 拡張のタイミングはいつか

## まとめ：効果的なMVP定義のためのチェックリスト

- [ ] 明確なユーザーペルソナとユーザーストーリーが定義されているか
- [ ] コア機能が優先順位付けされているか
- [ ] 各機能の技術的実現可能性が評価されているか
- [ ] 明確な成功指標が設定されているか
- [ ] フィードバック収集メカニズムが計画されているか
- [ ] 将来の拡張パスが考慮されているか
- [ ] リソース制約内で実現可能か
- [ ] チーム全体がMVPの範囲と目的を理解しているか